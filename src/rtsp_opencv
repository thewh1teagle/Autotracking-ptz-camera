#!/usr/bin/python3

import numpy as np
import sys
import cv2
from threading import Thread
import requests
from time import sleep


MOTOR_LOCK = False





def lock_motor():
    global MOTOR_LOCK
    MOTOR_LOCK = True
    sleep(1)
    MOTOR_LOCK = False

def lock_motor_thread():
    Thread(target=lock_motor()).start()


face_width, face_height = 130, 130

def motor_move(cam_ip, port, motor, direction, steps) -> bool:
    if MOTOR_LOCK:
        return
    lock_motor()
    response = requests.get("http://{}:{}/motor_move/{}/{}/{}".format(cam_ip, port, motor, direction, steps))
    if response.text == "max":
        return False # MAX offset
    return True

class ThreadedCamera(object):
    def __init__(self, source = 0):

        self.capture = cv2.VideoCapture(source)

        self.thread = Thread(target = self.update, args = ())
        self.thread.daemon = True
        self.thread.start()

        self.status = False
        self.frame  = None

    def update(self):
        while True:
            if self.capture.isOpened():
                (self.status, self.frame) = self.capture.read()

    def grab_frame(self):
        if self.status:
            return self.frame
        return None




if __name__ == '__main__':

    cam_ip = "192.168.1.117"
    port = 8080
    streamer = ThreadedCamera(f"rtsp://{cam_ip}:8554/substream")
    face_cascade = cv2.CascadeClassifier('haarcascade_frontalface_default.xml')

    
    frame_w = int(streamer.capture.get(cv2.CAP_PROP_FRAME_WIDTH))
    frame_h = int(streamer.capture.get(cv2.CAP_PROP_FRAME_HEIGHT))
    center_x = frame_w // 2
    center_y = frame_h // 2



    while True:
        frame = streamer.grab_frame()
        if frame is not None:
            faces = face_cascade.detectMultiScale(frame, 1.1, 4)
            for (x, y, w, h) in faces:
                if len(faces) == 1:
                    if y + h // 2 > center_y + face_height // 2:
                        print("moving reverse")
                        motor_move(cam_ip, port, "tilt", "reverse", 5) 
                    elif y - h // 2 < center_y - face_height // 2:
                        motor_move(cam_ip, port, "tilt", "forward", 5) 
                        print("moving forward")
                cv2.rectangle(frame, (x, y), (x+w, y+h), (255, 0, 0), 2)
            cv2.imshow("Context", frame)
        cv2.waitKey(1)
